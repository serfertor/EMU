# Эмулятор Процессора - Документация

## Описание

Полнофункциональный эмулятор процессора с Гарвардской архитектурой, реализованный на Python с графическим интерфейсом на базе Tkinter.

## Основные характеристики

### Архитектура
- **Тип**: Гарвардская архитектура (отдельная память программ и данных)
- **Адресность**: 3-адресные команды
- **Размер инструкции**: 40 бит
- **Формат**: `[opcode(4)|ad1(2).op1(16)|ad2(2).op2(16)]`

### Компоненты системы

#### 1. Регистры
- **EAX** - аккумулятор (регистр результатов)
- **EBX** - базовый регистр (для адресации)
- **ECX** - счётчик (для циклов)
- **EDX** - регистр данных
- **PC** - счётчик команд (Program Counter)
- **IR** - регистр команд (Instruction Register)

#### 2. Флаги
- **Z (Zero)** - флаг нуля (устанавливается, если результат = 0)
- **S (Sign)** - флаг знака (устанавливается, если результат < 0)

#### 3. Память
- **ОЗУ (RAM)** - 4096 ячеек по 16 бит
- Хранит данные и переменные программы
- Адресуется от 0 до 4095

### Система команд

#### Команды передачи данных
```
MOV ad1 op1 ad2 op2   - Передача: op1 = op2
```

#### Арифметические команды
```
ADD ad1 op1 ad2 op2   - Сложение: op1 = op1 + op2 (обновляет Z, S)
SUB ad1 op1 ad2 op2   - Вычитание: op1 = op1 - op2 (обновляет Z, S)
MUL ad1 op1 ad2 op2   - Умножение: op1 = op1 * op2
DIV ad1 op1 ad2 op2   - Деление: op1 = op1 / op2
```

#### Логические команды
```
AND ad1 op1 ad2 op2   - Побитовое И: op1 = op1 & op2
OR  ad1 op1 ad2 op2   - Побитовое ИЛИ: op1 = op1 | op2
XOR ad1 op1 ad2 op2   - Побитовое исключающее ИЛИ: op1 = op1 ^ op2
NOT ad1 op1            - Побитовое НЕ: op1 = ~op1
```

#### Специальные команды
```
INC ad1 op1            - Инкремент: op1 = op1 + 1
CMP ad1 op1 ad2 op2   - Сравнение: обновляет флаги без сохранения результата
```

#### Команды управления потоком
```
JMP ad1 op1            - Безусловный переход на адрес op1
JZ  ad1 op1            - Переход если Z=1 (результат равен нулю)
JNZ ad1 op1            - Переход если Z=0 (результат не равен нулю)
JS  ad1 op1            - Переход если S=1 (результат отрицательный)
JNS ad1 op1            - Переход если S=0 (результат положительный)
```

### Типы адресации

| Код | Название | Пример | Описание |
|-----|----------|--------|----------|
| 00 | Регистровая | `eax` | Значение находится в регистре |
| 01 | Непосредственная | `123` | Прямое числовое значение |
| 10 | Косвенно-регистровая | `[eax]` | Адрес памяти в регистре |
| 11 | Прямая | `[123]` | Прямой адрес памяти |

## Примеры программ

### Задача 1: Сумма элементов массива

Вычисление суммы 6 элементов массива:

```asm
mov [0] 6        ; [0] = количество элементов
mov [1] 100
mov [2] 2
mov [3] 3
mov [4] 4
mov [5] 5
mov [6] 6
mov ecx [0]      ; ecx = 6 (счётчик)
add eax [ecx]    ; eax += массив[ecx]
sub ecx 1        ; ecx--
jnz 8            ; если ecx != 0, переход на строку 8
```

**Результат**: EAX = 100 + 2 + 3 + 4 + 5 + 6 = 120

### Задача 2: Свертка двух массивов

Вычисление скалярного произведения двух массивов по 10 элементов:

```asm
mov [0] 10       ; Размер массивов
; Инициализация первого массива (адреса 1-10): все элементы = 1
mov [1] 1
mov [2] 1
...
mov [10] 1

; Инициализация второго массива (адреса 11-20): все элементы = 2
mov [11] 2
mov [12] 2
...
mov [20] 2

mov ecx [0]      ; ecx = 10
mov ebx ecx      ; ebx = 10
add ebx [0]      ; ebx = 10 + 10 = 20 (смещение на второй массив)
mov edx [ecx]    ; edx = первый_массив[ecx]
mul edx [ebx]    ; edx = edx * второй_массив[ebx]
add eax edx      ; eax += произведение
sub ecx 1        ; ecx--
jnz 22           ; если ecx != 0, переход на строку 22
```

**Результат**: EAX = 1*2 + 1*2 + ... + 1*2 (10 раз) = 20

## Использование

### Запуск эмулятора

```bash
python3 processor_emulator.py
```

### Интерфейс

1. **Ввод программы** - текстовая область для ввода ассемблерного кода
2. **Кнопки управления**:
   - **Загрузить** - парсинг и загрузка программы
   - **Шаг** - выполнить одну инструкцию
   - **Запуск** - автоматическое выполнение до конца
   - **Сброс** - очистка состояния
   - **Задача 1** и **Задача 2** - загрузка готовых примеров

3. **Отображение состояния**:
   - Текущие значения всех регистров
   - Состояние флагов (Z, S)
   - Программный счётчик (PC)
   - Текущую инструкцию (IR) в ассемблере и двоичном виде
   - Содержимое памяти
   - Консоль с логом выполнения

## Особенности реализации

### Кодирование инструкций

Каждая инструкция занимает 40 бит:

```
[Opcode(4 бит) | Addressing Mode 1(2 бита) . Operand 1(16 бит) | 
 Addressing Mode 2(2 бита) . Operand 2(16 бит)]
```

Пример: `mov ecx [0]`
- Opcode MOV: `0000`
- Адресация 1 (регистр): `00`
- Операнд 1 (ECX): `0000000000000010`
- Адресация 2 (прямая): `11`
- Операнд 2 (адрес 0): `0000000000000000`

### Обновление флагов

Флаги Z (Zero) и S (Sign) обновляются автоматически при выполнении:
- ADD, SUB (арифметические операции)
- CMP (команда сравнения)

### Косвенная адресация

При использовании косвенной адресации `[ecx]`:
1. Берется значение из регистра (адрес)
2. По этому адресу читается/записывается значение в памяти

Пример:
```
ecx = 5
[ecx] = RAM[5]
```

## Ограничения и особенности

1. **Диапазон значений**: -2^15 до 2^15-1 (для 16-битных значений)
2. **Размер памяти**: 4096 ячеек (0-4095)
3. **Максимум команд**: 10000 при автоматическом выполнении
4. **Целые числа**: поддерживаются только целые числа со знаком

## Структура исходного кода

```
processor_emulator.py
├── Instruction (dataclass)      # Структура инструкции
├── Emulator (class)              # Основной класс эмулятора
│   ├── parse_program()           # Парсинг ассемблера
│   ├── execute_step()            # Выполнение одной команды
│   ├── run_auto()                # Автоматическое выполнение
│   └── [операции...]             # Реализация команд
└── EmulatorGUI (class)           # Графический интерфейс
    ├── create_widgets()          # Создание элементов
    ├── update_display()          # Обновление дисплея
    └── [обработчики...]          # Обработчики событий
```

## Требования

- Python 3.8+
- tkinter (обычно встроен в Python)

## Автор

Реализовано как учебный проект для понимания архитектуры процессоров.

---

**Версия**: 1.0  
**Дата**: Декабрь 2025
