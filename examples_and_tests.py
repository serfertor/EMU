#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Примеры программ и тесты для эмулятора процессора
"""

# Примеры программ на ассемблере

TASK_1_SUM_ARRAY = """
; Задача 1: Сумма элементов массива
; Дано: массив из 6 элементов в ячейках памяти [1]-[6]
; Результат: сумма в регистре EAX
; Время: O(n)

mov [0] 6        ; [0] = количество элементов (6)
mov [1] 100      ; Первый элемент массива
mov [2] 2
mov [3] 3
mov [4] 4
mov [5] 5
mov [6] 6
mov ecx [0]      ; ECX = 6 (счётчик цикла)
add eax [ecx]    ; EAX += массив[ECX]
sub ecx 1        ; ECX-- (ECX становится 5, потом 4, 3, 2, 1)
jnz 8            ; Если Z != 1, перейти на строку 8 (add)
"""

TASK_2_CONVOLUTION = """
; Задача 2: Свертка (скалярное произведение) двух массивов
; Дано: Два массива по 10 элементов
;       Массив 1: адреса [1]-[10], все элементы = 1
;       Массив 2: адреса [11]-[20], все элементы = 2
; Результат: скалярное произведение в регистре EAX
; Ожидаемый результат: 1*2*10 = 20

mov [0] 10       ; [0] = размер массива (10)

; Инициализация первого массива (значения = 1)
mov [1] 1
mov [2] 1
mov [3] 1
mov [4] 1
mov [5] 1
mov [6] 1
mov [7] 1
mov [8] 1
mov [9] 1
mov [10] 1

; Инициализация второго массива (значения = 2)
mov [11] 2
mov [12] 2
mov [13] 2
mov [14] 2
mov [15] 2
mov [16] 2
mov [17] 2
mov [18] 2
mov [19] 2
mov [20] 2

mov ecx [0]      ; ECX = 10 (счётчик цикла)
mov ebx ecx      ; EBX = ECX = 10
add ebx [0]      ; EBX = EBX + 10 = 20 (смещение на второй массив)
mov edx [ecx]    ; EDX = первый_массив[ECX]
mul edx [ebx]    ; EDX = EDX * второй_массив[EBX]
add eax edx      ; EAX += произведение
sub ecx 1        ; ECX-- (от 10 к 1)
jnz 22           ; Если Z != 1, перейти на строку 22 (mov edx)
"""

# Дополнительные примеры

EXAMPLE_FACTORIAL = """
; Вычисление факториала N!
; Результат в EAX
; Пример: факториал(5) = 120

mov [0] 5        ; N = 5
mov ecx [0]      ; ECX = 5 (счётчик)
mov eax 1        ; EAX = 1 (аккумулятор результата)
mul eax ecx      ; EAX *= ECX
sub ecx 1        ; ECX--
jnz 3            ; Если ECX != 0, перейти на mul
"""

EXAMPLE_FIBONACCI = """
; Вычисление N-го числа Фибоначчи
; Результат в EAX
; Последовательность: 1, 1, 2, 3, 5, 8, 13, 21, ...

mov [0] 8        ; Вычисляем 8-е число Фибоначчи
mov eax 1        ; F(1) = 1
mov ebx 1        ; F(2) = 1
mov ecx [0]      ; ECX = N
mov edx 2        ; EDX = 2 (счётчик, начинаем с F(3))
add eax ebx      ; новое значение = eax + ebx
mov ebx eax      ; сдвигаем: ebx = новое значение
mov eax ebx      ; eax = ebx (подготовка для следующей итерации)
inc edx          ; EDX++
cmp edx ecx      ; Сравниваем EDX с ECX
jnz 5            ; Если не равны, повторить
"""

EXAMPLE_POWER = """
; Вычисление A^B (A в степени B)
; [0] = основание A
; [1] = показатель B
; Результат в EAX
; Пример: 2^10 = 1024

mov [0] 2        ; A = 2
mov [1] 10       ; B = 10

mov eax 1        ; EAX = 1 (результат)
mov ebx [0]      ; EBX = A (множитель)
mov ecx [1]      ; ECX = B (счётчик)
mul eax ebx      ; EAX *= EBX
sub ecx 1        ; ECX--
jnz 4            ; Повторить, если ECX != 0
"""

EXAMPLE_MAXIMUM = """
; Поиск максимума в массиве
; [0] = количество элементов
; [1]-[n] = элементы массива
; Результат в EAX

mov [0] 5        ; Размер массива = 5
mov [1] 15
mov [2] 8
mov [3] 23
mov [4] 12
mov [5] 19

mov eax [1]      ; EAX = первый элемент
mov ecx 2        ; ECX = 2 (индекс следующего элемента)
mov ebx [0]      ; EBX = размер
inc ebx          ; EBX++ (адрес последнего элемента + 1)
cmp eax [ecx]    ; Сравнить EAX с текущим элементом
jns 5            ; Если EAX >= элемента, перейти дальше
mov eax [ecx]    ; Иначе EAX = текущий элемент
inc ecx          ; ECX++ (переход к следующему элементу)
cmp ecx ebx      ; Проверить, все ли элементы обработаны
jnz 4            ; Если нет, повторить
"""

EXAMPLE_PARITY_CHECK = """
; Проверка чётности числа
; [0] = число
; Результат: EAX = 1 если чётное, 0 если нечётное

mov [0] 42       ; Число = 42

mov eax [0]      ; EAX = число
and eax 1        ; EAX &= 1 (проверка младшего бита)
xor eax 1        ; EAX ^= 1 (инвертируем: чётные -> 1, нечётные -> 0)
"""

EXAMPLE_ARRAY_REVERSAL = """
; Разворот массива (обратный порядок)
; [0] = размер массива
; [1]-[n] = элементы массива
; Результат: массив перевёрнут на месте

mov [0] 5
mov [1] 10
mov [2] 20
mov [3] 30
mov [4] 40
mov [5] 50

mov ecx 1        ; ECX = начальный индекс
mov ebx [0]      ; EBX = размер
mov edx 0        ; EDX = временное хранилище
mov eax [ecx]    ; EAX = элемент с начала
mov edx [ebx]    ; EDX = элемент с конца
mov [ecx] edx    ; Поместить конец в начало
mov [ebx] eax    ; Поместить начало в конец
inc ecx          ; ECX++
dec ebx          ; EBX--
cmp ecx ebx      ; Сравнить индексы
jns 5            ; Если встретились, выход
"""

# Коды возможных ошибок и исключительные ситуации

TEST_CASES = [
    {
        'name': 'Базовая арифметика',
        'code': """
mov eax 5
add eax 3
""",
        'expected_eax': 8,
        'expected_flags': {'z': 0, 's': 0}
    },
    {
        'name': 'Отрицательный результат',
        'code': """
mov eax 3
sub eax 5
""",
        'expected_eax': -2,
        'expected_flags': {'z': 0, 's': 1}
    },
    {
        'name': 'Нулевой результат',
        'code': """
mov eax 5
sub eax 5
""",
        'expected_eax': 0,
        'expected_flags': {'z': 1, 's': 0}
    },
    {
        'name': 'Условный переход JNZ',
        'code': """
mov eax 10
sub eax 5
jnz 2
mov eax 0
""",
        'expected_eax': 5,
        'description': 'JNZ не должна выполниться (eax != 0)'
    },
    {
        'name': 'Условный переход JZ',
        'code': """
mov eax 10
sub eax 10
jz 2
mov eax 999
""",
        'expected_eax': 0,
        'description': 'JZ должна выполниться (eax == 0)'
    },
    {
        'name': 'Память и косвенная адресация',
        'code': """
mov [5] 42
mov ecx 5
mov eax [ecx]
""",
        'expected_eax': 42,
        'expected_memory': {5: 42}
    },
    {
        'name': 'Логические операции',
        'code': """
mov eax 12
and eax 10
""",
        'expected_eax': 8,
        'description': '1100 AND 1010 = 1000 (8 в десятичном)'
    }
]


def print_program_guide():
    """Вывести справку по написанию программ"""
    print("""
╔═══════════════════════════════════════════════════════════════╗
║          СПРАВКА: СИНТАКСИС АССЕМБЛЕРА                       ║
╚═══════════════════════════════════════════════════════════════╝

ФОРМАТ ИНСТРУКЦИИ:
  OPCODE operand1 operand2

ТИПЫ ОПЕРАНДОВ:
  - Регистры: eax, ebx, ecx, edx
  - Числа: 123, -45
  - Память (прямая): [0], [100]
  - Память (косвенная): [eax], [ecx]

ПРИМЕРЫ:
  mov eax 5          # Загрузить 5 в EAX
  mov [0] 10         # Загрузить 10 в ячейку памяти [0]
  mov eax [0]        # Загрузить значение из [0] в EAX
  add eax [ecx]      # Добавить значение из [ECX] в EAX
  
ЦИКЛЫ:
  mov ecx 10         # Инициализировать счётчик
loop_label:
  ; тело цикла
  sub ecx 1          # Уменьшить счётчик
  jnz loop_label     # Повторить, если счётчик != 0

КОММЕНТАРИИ:
  ; это комментарий

╔═══════════════════════════════════════════════════════════════╗
║                    ПРАКТИЧЕСКИЕ СОВЕТЫ                       ║
╚═══════════════════════════════════════════════════════════════╝

1. Используйте ECX как счётчик цикла (по историческим традициям)
2. Используйте EAX как аккумулятор для результатов
3. Используйте EBX для временного хранения или адресации
4. Используйте EDX для вспомогательных данных

5. Помните об обновлении флагов:
   - Z флаг устанавливается после ADD, SUB, CMP
   - S флаг показывает знак результата

6. Для безопасности добавляйте граничные проверки в циклах

7. Инициализируйте регистры перед использованием

8. Используйте прямую адресацию [0], [1] для параметров
   и косвенную [eax], [ecx] для доступа к элементам массивов
    """)


if __name__ == '__main__':
    print("Примеры и тесты для эмулятора процессора")
    print_program_guide()
